# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_IOUtils.ipynb (unless otherwise specified).

__all__ = ['readAbstractMethodsFromFile', 'writeAbstractMethodsToFile', 'getYamlParameter', 'runCommand']

# Cell
#hide
from typing import List, Iterable
import re
import subprocess
import sys

import sys
sys.path.append("..")

from .AbstractMethod import *

# Cell
def readAbstractMethodsFromFile(file: str) -> List[AbstractMethod]:
    """
    Returns a list of `AbstractMethods` read from the given `file`. The file should have one `AbstractMethod`
    per line with tokens separated by spaces.
    """

    abstractMethods = []

    with open(file, "r") as f:
        for line in f:
            abstractMethods.append(AbstractMethod(line.strip()))

    return abstractMethods

# Cell
def writeAbstractMethodsToFile(file: str, abstractMethods: List[AbstractMethod]) -> None:
    """
    Writes the given `abstractMethods` to the given `file` such that one `AbstractMethod` is written per line.
    """

    with open(file, "w") as f:

        for i in range(len(abstractMethods)):

            f.write(str(abstractMethods[i]))

            if i < len(abstractMethods) - 1:
                f.write("\n")

# Cell
#hide
def getYamlParameter(yamlFile: str, key: str) -> str:
    """
    Returns the value of the given `key` in the given `yamlFile`. If the parameter was not found,
    Returns None.
    """

    with open(yamlFile, "r") as file:
        for line in file:
            match = re.search(r"^\s*" + key + r"\s*:\s*(.+)", line)
            if (match):
                return match.group(1).strip()

    return None

# Cell
#hide
def runCommand(command: Iterable[str]) -> str:
    """
    Runs the given command in the shell and continuously prints its output. If the command failed, raises
    a ProcessException.
    """

    # run the command
    process = subprocess.Popen(command, shell = True, stdout = subprocess.PIPE, stderr = subprocess.STDOUT)

    while True:

        line = process.stdout.readline()

        # break out if the process has finished and there is no more output to print
        if process.poll() is not None and line == b"":
            break

        sys.stdout.write(line)
        sys.stdout.flush()

    exitCode = process.returncode

    if exitCode != 0:
        raise subprocess.CalledProcessError(exitCode, command, "")